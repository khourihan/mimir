use std::str::FromStr;
use crate::{expr::{Expr, Num, Var, Fun, Pow, Mul, Add}, parser::TermOp};
use lalrpop_util::ErrorRecovery;
use ordered_float::OrderedFloat;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, &'static str>>);

pub Expr: Box<Expr> = {
    <t:Term> <ts:(<TermOp>)*> => {
        if ts.is_empty() {
            t
        } else {
            let terms = std::iter::once(t)
                .chain(ts.into_iter().map(|t| match t {
                    TermOp::Add(expr) => expr,
                    TermOp::Sub(expr) => Box::new(expr.mul(Expr::Num(Num::Integer(-1)))),
                }))
                .collect();
            Box::new(Expr::Add(Add::new_boxed(terms)))
        }
    }
};

pub TermOp: TermOp = {
    "+" <Term> => TermOp::Add(<>),
    "-" <Term> => TermOp::Sub(<>),
};

pub Term: Box<Expr> = {
    <left:Term> "*" <right:Factor> => Box::new(left.mul(*right)),
    <left:Term> "/" <right:Factor> => Box::new(left.mul(right.pow(Expr::Num(Num::Integer(-1))))),
    <left:Term> <right:Atom> => Box::new(left.mul(*right)),
    <left:Term> <base:Atom> "^" <exp:FactorRhs> => Box::new(left.mul(base.pow(*exp))),
    Factor
};

pub Factor: Box<Expr> = {
    <left:Atom> "^" <right:FactorRhs> => Box::new(Expr::Pow(Pow::new_boxed(left, right))),
    "-" <expr:Factor> => Box::new(expr.mul(Expr::Num(Num::Integer(-1)))),
    Atom,
};

pub FactorRhs: Box<Expr> = {
    "-" <expr:Atom> => Box::new(expr.mul(Expr::Num(Num::Integer(-1)))),
    Atom,
};

pub Atom: Box<Expr> = {
    Integer => Box::new(Expr::Num(<>)),
    Real => Box::new(Expr::Num(<>)),
    Var => Box::new(Expr::Var(Var::from_name(<>))),
    "(" <Expr> ")",
    <name:Var> "[" <args:Comma<Expr>> "]" => Box::new(Expr::Fun(Fun::from_name(name, args))),
};

Integer: Num = r"[0-9]+" => Num::Integer(i32::from_str(<>).unwrap());
Real: Num = r"[0-9]+\.[0-9]*|[+-]?\.[0-9]+" => Num::Float(OrderedFloat(f32::from_str(<>).unwrap()));
Var: String = r"[a-zA-Z][a-zA-Z0-9_]*" => String::from(<>);

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
