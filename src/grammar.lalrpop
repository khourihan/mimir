use std::str::FromStr;
use crate::parser::{Expr, BinaryOpCode, UnaryOpCode};
use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, &'static str>>);

pub Expr: Box<Expr> = {
    <left:Expr> <op:ExprOp> <right:Term> => Box::new(Expr::BinaryOp {<>}),
    Term,
    ! => { errors.push(<>); Box::new(Expr::Error) }
};

pub Term: Box<Expr> = {
    <left:Term> <op:TermOp> <right:Factor> => Box::new(Expr::BinaryOp {<>}),
    <left:Term> <right:Atom> => Box::new(Expr::BinaryOp { op: BinaryOpCode::Mul, left, right }),
    Factor,
};

pub Factor: Box<Expr> = {
    <left:Atom> <op:FactorOp> <right:FactorRhs> => Box::new(Expr::BinaryOp {<>}),
    <op:UnaryOp> <expr:Factor> => Box::new(Expr::UnaryOp {<>}),
    Atom,
};

pub FactorRhs: Box<Expr> = {
    <op:UnaryOp> <expr:Atom> => Box::new(Expr::UnaryOp {<>}),
    Atom,
};

pub Atom: Box<Expr> = {
    Integer => Box::new(Expr::Integer(<>)),
    Real => Box::new(Expr::Real(<>)),
    Ident => Box::new(Expr::Ident(<>)),
    "(" <Expr> ")",
    <name:Ident> "[" <args:Comma<Expr>> "]" => Box::new(Expr::Call {<>}),
};

ExprOp: BinaryOpCode = {
    "+" => BinaryOpCode::Add,
    "-" => BinaryOpCode::Sub,
};

TermOp: BinaryOpCode = {
    "*" => BinaryOpCode::Mul,
    "/" => BinaryOpCode::Div,
};

FactorOp: BinaryOpCode = {
    "^" => BinaryOpCode::Pow,
};

UnaryOp: UnaryOpCode = {
    "-" => UnaryOpCode::Neg,
};

Integer: i32 = r"[0-9]+" => i32::from_str(<>).unwrap();
Real: f32 = r"[0-9]+\.[0-9]*|[+-]?\.[0-9]+" => f32::from_str(<>).unwrap();
Ident: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => String::from(<>);

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
