use std::str::FromStr;
use crate::parser::{Expr, OpCode};
use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, &'static str>>);

pub Expr: Box<Expr> = {
    <left:Expr> <op:ExprOp> <right:Term> => Box::new(Expr::BinaryOp{<>}),
    Term,
    ! => { errors.push(<>); Box::new(Expr::Error) }
};

pub Term: Box<Expr> = {
    <left:Term> <op:TermOp> <right:Factor> => Box::new(Expr::BinaryOp{<>}),
    Factor,
};

pub Factor: Box<Expr> = {
    Integer => Box::new(Expr::Integer(<>)),
    Real => Box::new(Expr::Real(<>)),
    Ident => Box::new(Expr::Ident(<>)),
    "(" <Expr> ")",
};

ExprOp: OpCode = {
    "+" => OpCode::Add,
    "-" => OpCode::Sub,
};

TermOp: OpCode = {
    "*" => OpCode::Mul,
    "/" => OpCode::Div,
};

Integer: i32 = r"[+-]?[0-9]+" => i32::from_str(<>).unwrap();
Real: f32 = r"[+-]?[0-9]+\.[0-9]*|[+-]?\.[0-9]+" => f32::from_str(<>).unwrap();
Ident: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => String::from(<>);
