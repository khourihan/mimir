use std::str::FromStr;
use crate::expr::{Statement, Expr, AssertOpCode, BinaryOpCode, UnaryOpCode};
use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, &'static str>>);

pub Statement: Box<Statement> = {
    <left:Expr> <op:AssertOp> <right:Expr> => Box::new(Statement::Assertion {<>}),
    <pattern:Expr> "=>" <result:Expr> => Box::new(Statement::Reduction {<>}),
    Expr => Box::new(Statement::Expr(<>)),
    ! => { errors.push(<>); Box::new(Statement::Error) }
};

pub Expr: Box<Expr> = {
    "{" <mut stmts:(<Statement> ";")*> <expr:Expr> "}" => Box::new(Expr::Block {<>}),
    CompExpr,
};

pub CompExpr: Box<Expr> = {
    <left:MathExpr> <op:CompExprOp> <right:MathExpr> => Box::new(Expr::BinaryOp {<>}),
    MathExpr,
};

pub MathExpr: Box<Expr> = {
    <left:MathExpr> <op:ExprOp> <right:Term> => Box::new(Expr::BinaryOp {<>}),
    Term,
};

pub Term: Box<Expr> = {
    <left:Term> <op:TermOp> <right:Factor> => Box::new(Expr::BinaryOp {<>}),
    <left:Term> <right:Atom> => Box::new(Expr::BinaryOp { op: BinaryOpCode::Mul, left, right }),
    Factor,
};

pub Factor: Box<Expr> = {
    <left:Atom> <op:FactorOp> <right:FactorRhs> => Box::new(Expr::BinaryOp {<>}),
    <op:UnaryOp> <expr:Factor> => Box::new(Expr::UnaryOp {<>}),
    Atom,
};

pub FactorRhs: Box<Expr> = {
    <op:UnaryOp> <expr:Atom> => Box::new(Expr::UnaryOp {<>}),
    Atom,
};

pub Atom: Box<Expr> = {
    Integer => Box::new(Expr::Integer(<>)),
    Real => Box::new(Expr::Real(<>)),
    Ident => Box::new(Expr::Var(<>)),
    "(" <MathExpr> ")",
    <name:Ident> "[" <args:Comma<MathExpr>> "]" => Box::new(Expr::Call {<>}),
};

AssertOp: AssertOpCode = {
    ":=" => AssertOpCode::Eq,
    ":<" => AssertOpCode::Lt,
    ":>" => AssertOpCode::Gt,
    ":<=" => AssertOpCode::Lte,
    ":>=" => AssertOpCode::Gte,
}

CompExprOp: BinaryOpCode = {
    "==" => BinaryOpCode::Eq,
    "<" => BinaryOpCode::Lt,
    ">" => BinaryOpCode::Gt,
    "<=" => BinaryOpCode::Lte,
    ">=" => BinaryOpCode::Gte,
};

ExprOp: BinaryOpCode = {
    "+" => BinaryOpCode::Add,
    "-" => BinaryOpCode::Sub,
};

TermOp: BinaryOpCode = {
    "*" => BinaryOpCode::Mul,
    "/" => BinaryOpCode::Div,
};

FactorOp: BinaryOpCode = {
    "^" => BinaryOpCode::Pow,
};

UnaryOp: UnaryOpCode = {
    "-" => UnaryOpCode::Neg,
};

Integer: i32 = r"[0-9]+" => i32::from_str(<>).unwrap();
Real: f32 = r"[0-9]+\.[0-9]*|[+-]?\.[0-9]+" => f32::from_str(<>).unwrap();
Ident: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => String::from(<>);

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
