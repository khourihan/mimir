use std::str::FromStr;
use crate::expr::{Statement, Expr};
use lalrpop_util::ErrorRecovery;
use ordered_float::OrderedFloat;

grammar<'err, 'stmts>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, &'static str>>, stmts: &'stmts mut Vec<Box<Statement>>);

pub Statement: Box<Statement> = {
    <pattern:CompExpr> "=>" <result:CompExpr> => Box::new(Statement::Reduction { pattern: pattern.into(), result }),
    ! => { errors.push(<>); Box::new(Statement::Error) }
};

pub Expr: Option<Box<Expr>> = {
    "{" <s:(<Statement> ";")*> <expr:CompExpr?> "}" => { stmts.extend(s); expr },
    CompExpr => Some(<>),
};

pub CompExpr: Box<Expr> = {
    <left:MathExpr> <op:CompExprOp> <right:MathExpr> => Box::new(Expr::Call { name: op, args: vec![left, right] }),
    MathExpr,
};

pub MathExpr: Box<Expr> = {
    <left:MathExpr> <op:ExprOp> <right:Term> => Box::new(Expr::Call { name: op, args: vec![left, right] }),
    Term,
};

pub Term: Box<Expr> = {
    <left:Term> <op:TermOp> <right:Factor> => Box::new(Expr::Call { name: op, args: vec![left, right] }),
    <left:Term> <right:Atom> => Box::new(Expr::Call { name: String::from("mul"), args: vec![left, right] }),
    Factor,
};

pub Factor: Box<Expr> = {
    <left:Atom> <op:FactorOp> <right:FactorRhs> => Box::new(Expr::Call { name: op, args: vec![left, right] }),
    <op:UnaryOp> <expr:Factor> => Box::new(Expr::Call { name: op, args: vec![expr] }),
    Atom,
};

pub FactorRhs: Box<Expr> = {
    <op:UnaryOp> <expr:Atom> => Box::new(Expr::Call { name: op, args: vec![expr] }),
    Atom,
};

pub Atom: Box<Expr> = {
    Integer => Box::new(Expr::Integer(<>)),
    Real => Box::new(Expr::Real(<>)),
    Var => Box::new(Expr::Var(<>)),
    "(" <MathExpr> ")",
    <name:Var> "[" <args:Comma<MathExpr>> "]" => Box::new(Expr::Call {<>}),
};

CompExprOp: String = {
    "==" => String::from("eq"),
    "<" => String::from("lt"),
    ">" => String::from("gt"),
    "<=" => String::from("lte"),
    ">=" => String::from("gte"),
};

ExprOp: String = {
    "+" => String::from("add"),
    "-" => String::from("sub"),
};

TermOp: String = {
    "*" => String::from("mul"),
    "/" => String::from("div"),
};

FactorOp: String = {
    "^" => String::from("pow"),
};

UnaryOp: String = {
    "-" => String::from("neg"),
};

Integer: i32 = r"[0-9]+" => i32::from_str(<>).unwrap();
Real: OrderedFloat<f32> = r"[0-9]+\.[0-9]*|[+-]?\.[0-9]+" => OrderedFloat(f32::from_str(<>).unwrap());
Var: String = r"[a-zA-Z][a-zA-Z0-9_]*" => String::from(<>);

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Semicolon<T>: Vec<T> = {
    <mut v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
